---
title: "Production Deployment"
sidebarTitle: "Deployment"
description: "Deploy Screenshothis to production on various platforms and infrastructure providers."
---

# Production Deployment

This guide covers deploying Screenshothis to production environments across different platforms and infrastructure providers.

<Note>
**Important**: Always refer to the [Screenshothis repository](https://github.com/screenshothis/screenshothis) for the latest deployment instructions and configuration requirements.
</Note>

## Pre-Deployment Checklist

Before deploying to production, ensure you have:

- [ ] **Database**: PostgreSQL instance (managed or self-hosted)
- [ ] **Cache**: Redis instance (managed or self-hosted)
- [ ] **Storage**: S3-compatible storage service configured
- [ ] **Domain**: Domain name and SSL certificates
- [ ] **Environment Variables**: All required env vars configured
- [ ] **Secrets**: Secure JWT secrets and encryption keys
- [ ] **Monitoring**: Logging and monitoring solution ready

## Docker Deployment

### Single Container

The simplest production deployment using Docker:

```bash
# Build the application
docker build -t screenshothis:latest .

# Run the container
docker run -d \
  --name screenshothis \
  --env-file .env.production \
  -p 3000:3000 \
  --restart unless-stopped \
  screenshothis:latest
```

### Docker Compose Production Setup

```yaml
# docker-compose.prod.yml
version: '3.8'

services:
  screenshothis:
    build: .
    env_file:
      - .env.production
    ports:
      - "3000:3000"
    depends_on:
      - postgres
      - redis
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: screenshothis
      POSTGRES_USER: screenshothis
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    command: redis-server --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/ssl/certs
    depends_on:
      - screenshothis
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
```

### NGINX Configuration

```nginx
# nginx.conf
events {
    worker_connections 1024;
}

http {
    upstream screenshothis {
        server screenshothis:3000;
    }

    server {
        listen 80;
        server_name api.yourdomain.com;
        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl;
        server_name api.yourdomain.com;

        ssl_certificate /etc/ssl/certs/cert.pem;
        ssl_certificate_key /etc/ssl/certs/key.pem;

        client_max_body_size 10M;
        proxy_read_timeout 60s;

        location / {
            proxy_pass http://screenshothis;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /health {
            proxy_pass http://screenshothis/health;
            access_log off;
        }
    }
}
```

## Kubernetes Deployment

### Namespace and ConfigMap

```yaml
# k8s/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: screenshothis

---
# k8s/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: screenshothis-config
  namespace: screenshothis
data:
  NODE_ENV: "production"
  PORT: "3000"
  LOG_LEVEL: "info"
  MAX_SCREENSHOT_WIDTH: "3840"
  MAX_SCREENSHOT_HEIGHT: "2160"
```

### Secrets

```yaml
# k8s/secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: screenshothis-secrets
  namespace: screenshothis
type: Opaque
stringData:
  DATABASE_URL: "postgresql://user:password@postgres:5432/screenshothis"
  BETTER_AUTH_SECRET: "your-secure-auth-secret"
  AWS_ACCESS_KEY_ID: "your-s3-access-key"
  AWS_SECRET_ACCESS_KEY: "your-s3-secret-key"
```

### Deployment

```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: screenshothis
  namespace: screenshothis
spec:
  replicas: 3
  selector:
    matchLabels:
      app: screenshothis
  template:
    metadata:
      labels:
        app: screenshothis
    spec:
      containers:
      - name: screenshothis
        image: screenshothis:latest
        ports:
        - containerPort: 3000
        envFrom:
        - configMapRef:
            name: screenshothis-config
        - secretRef:
            name: screenshothis-secrets
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"

---
# k8s/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: screenshothis-service
  namespace: screenshothis
spec:
  selector:
    app: screenshothis
  ports:
  - port: 80
    targetPort: 3000
  type: ClusterIP

---
# k8s/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: screenshothis-ingress
  namespace: screenshothis
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
spec:
  tls:
  - hosts:
    - api.yourdomain.com
    secretName: screenshothis-tls
  rules:
  - host: api.yourdomain.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: screenshothis-service
            port:
              number: 80
```

### Deploy to Kubernetes

```bash
# Apply all configurations
kubectl apply -f k8s/

# Check deployment status
kubectl get pods -n screenshothis

# View logs
kubectl logs -f deployment/screenshothis -n screenshothis
```

## Cloud Platform Deployments

### AWS (EC2 + RDS + ElastiCache)

```bash
# 1. Launch EC2 instance
aws ec2 run-instances \
  --image-id ami-0abcdef1234567890 \
  --instance-type t3.medium \
  --key-name your-key-pair \
  --security-group-ids sg-903004f8 \
  --subnet-id subnet-6e7f829e

# 2. Create RDS PostgreSQL instance
aws rds create-db-instance \
  --db-instance-identifier screenshothis-db \
  --db-instance-class db.t3.micro \
  --engine postgres \
  --master-username screenshothis \
  --master-user-password your-password \
  --allocated-storage 20

# 3. Create ElastiCache Redis cluster
aws elasticache create-cache-cluster \
  --cache-cluster-id screenshothis-redis \
  --cache-node-type cache.t3.micro \
  --engine redis \
  --num-cache-nodes 1
```

### DigitalOcean Droplet

```bash
# Install Docker on Ubuntu droplet
sudo apt update
sudo apt install -y docker.io docker-compose
sudo systemctl start docker
sudo systemctl enable docker

# Clone and deploy
git clone https://github.com/screenshothis/screenshothis.git
cd screenshothis
cp .env.example .env.production
# Edit .env.production with your settings
docker-compose -f docker-compose.prod.yml up -d
```

### Google Cloud Platform (Cloud Run)

```dockerfile
# Dockerfile.cloudrun
FROM node:18-alpine

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

EXPOSE 8080
ENV PORT=8080

CMD ["npm", "start"]
```

```bash
# Build and deploy to Cloud Run
gcloud builds submit --tag gcr.io/your-project/screenshothis
gcloud run deploy screenshothis \
  --image gcr.io/your-project/screenshothis \
  --platform managed \
  --region us-central1 \
  --allow-unauthenticated \
  --set-env-vars NODE_ENV=production
```

### Railway

```json
// railway.json
{
  "build": {
    "builder": "NIXPACKS"
  },
  "deploy": {
    "startCommand": "npm start",
    "healthcheckPath": "/health",
    "healthcheckTimeout": 300
  }
}
```

## Environment-Specific Configurations

### Production Environment Variables

```bash
# .env.production
NODE_ENV=production
PORT=3000

# Database (use managed service)
DATABASE_URL=postgresql://user:pass@your-db-host:5432/screenshothis

# Redis (use managed service)
REDIS_URL=redis://your-redis-host:6379

# S3 Storage (use managed service)
AWS_ACCESS_KEY_ID=your_access_key
AWS_SECRET_ACCESS_KEY=your_secret_key
AWS_REGION=us-east-1
AWS_BUCKET=your-production-bucket
AWS_URL=https://s3.us-east-1.amazonaws.com

# Application URLs
APP_URL=https://api.yourdomain.com
WEB_URL=https://yourdomain.com

# Authentication
BETTER_AUTH_SECRET=super-secure-random-string-for-production
DEFAULT_API_KEY_PREFIX=ss_live_

# Performance
MAX_CONCURRENT_SCREENSHOTS=20
RATE_LIMIT_MAX_REQUESTS=1000

# Monitoring
LOG_LEVEL=info
ENABLE_METRICS=true
```

## SSL/TLS Configuration

### Let's Encrypt with Certbot

```bash
# Install certbot
sudo apt install certbot python3-certbot-nginx

# Get certificate
sudo certbot --nginx -d api.yourdomain.com

# Auto-renewal
sudo crontab -e
# Add: 0 12 * * * /usr/bin/certbot renew --quiet
```

### Manual SSL Setup

```bash
# Generate SSL certificate (if not using Let's Encrypt)
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  -keyout /etc/ssl/private/screenshothis.key \
  -out /etc/ssl/certs/screenshothis.crt
```

## Monitoring and Logging

### Health Checks

The application provides several health check endpoints:

- `/health` - Basic health check
- `/health/live` - Liveness probe
- `/health/ready` - Readiness probe

### Prometheus Metrics

```yaml
# docker-compose.monitoring.yml
version: '3.8'
services:
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml

  grafana:
    image: grafana/grafana
    ports:
      - "3001:3000"
    environment:
      GF_SECURITY_ADMIN_PASSWORD: admin
```

### Log Management

```yaml
# Add to docker-compose.prod.yml
services:
  screenshothis:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
```

## Scaling Considerations

### Horizontal Scaling

```yaml
# k8s/hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: screenshothis-hpa
  namespace: screenshothis
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: screenshothis
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
```

### Database Scaling

- Use read replicas for read-heavy workloads
- Consider connection pooling (PgBouncer)
- Monitor query performance

### Redis Scaling

- Use Redis Cluster for high availability
- Consider Redis Sentinel for failover

## Backup and Recovery

### Database Backups

```bash
# Automated PostgreSQL backup
#!/bin/bash
DATE=$(date +%Y%m%d_%H%M%S)
pg_dump $DATABASE_URL > backup_$DATE.sql
aws s3 cp backup_$DATE.sql s3://your-backup-bucket/
```

### Application Data Backup

```bash
# Backup uploaded files (if using local storage)
tar -czf screenshots_backup_$(date +%Y%m%d).tar.gz /path/to/screenshots
aws s3 cp screenshots_backup_*.tar.gz s3://your-backup-bucket/
```

## Security Hardening

### Firewall Configuration

```bash
# UFW firewall rules
sudo ufw allow ssh
sudo ufw allow 80
sudo ufw allow 443
sudo ufw enable
```

### Docker Security

```dockerfile
# Use non-root user
FROM node:18-alpine
RUN addgroup -g 1001 -S nodejs
RUN adduser -S screenshothis -u 1001
USER screenshothis
```

## Troubleshooting Deployment Issues

Common deployment problems and solutions:

### Port Binding Issues

```bash
# Check what's using the port
sudo netstat -tulpn | grep :3000
sudo lsof -i :3000
```

### Database Connection Issues

```bash
# Test database connection
psql $DATABASE_URL -c "SELECT version();"
```

### Storage Issues

```bash
# Test S3 connection
aws s3 ls s3://your-bucket --region your-region
```

## Next Steps

- [Configuration Guide](/self-host/configuration) - Detailed configuration options
- [Troubleshooting](/self-host/troubleshooting) - Common issues and solutions

---

**Need help?** Check our [troubleshooting guide](/self-host/troubleshooting) or [open an issue](https://github.com/screenshothis/screenshothis/issues) on GitHub.
